# Getting Started with This App

## Tool Prerequisites

You must have these tools installed
- NVM or NodeJS
- [Truffle](https://trufflesuite.com/docs/truffle/)
    > npm i truffle -g
- [Ganache](https://trufflesuite.com/ganache/index.html)
 - Personal Ethereum Blockchain
- [solidity](https://marketplace.visualstudio.com/items?itemName=JuanBlanco.solidity)
- [vscode-styled-components](https://marketplace.visualstudio.com/items?itemName=styled-components.vscode-styled-components)

## Optional Prerquisites

Add these VS Code extensions for productivity, code highlighting and debugging: 

- [solidity-extended](https://marketplace.visualstudio.com/items?itemName=beaugunderson.solidity-extended)
- [solidity-debugger](https://marketplace.visualstudio.com/items?itemName=hosho.solidity-debugger)

## Start Branch

We used Create React App to setup a working React project with some styles and pre-existing components, the rest we will build from scratch!

Some of the command we have already run are:

```bash
npx create-react-app stablecoin-nft-ticket-workshop`
```

```bash
npm i polished styled-components
```

```bash
npm i @openzeppelin/contracts
```

Run `npm i && npm start` and ensure that you get a standard React Projects with no errors in the terminal or in the browser console.

## Start Here

1. We will start by initializing Truffle in our repository:

```bash
truffle init
```

This will add a config, a migrations contract, an actual migrations javascript file and a directory for tests:

```
├── truffle-config.js  
├── contracts  
│   └── Migrations.sol  
├── migrations  
│   └── 1_initial_migration.js  
├── test  
│   └── .gitkeep  
```

2. Next we will open up Ganache and create a New Workspace with the same name as our repo: `nft-tickets-workshop` and connect your project by selecting Add Project and navigating to the `truffle-config.js` file we just created in the root of our project. Finally click Save Workspace and we get get access to a local blockchain specific for our project.

![](./assets-readme/ganache-1.png)

3. In our `truffle-config.js` file we want to uncomment the following lines:

- lines 44 through 48 (change the port to: `7545` to match Ganache RPC server port)
- line 84 (ensure we have a fairly up to date version `0.8.11`)

4. We will use Truffle to create our Contract:

```bash
truffle create contract Foxcon2022
```

This will create inside of our `contracts` directory a file named: `Foxcon2022.sol` with some basic contract code.

5. We will test out one more Truffle command real quick and see that the contract we just added will compile (as it should)

```bash
truffle compile
```

Although you may see a warning in the terminal our contract did compile, we can resolve the warnings as we build out our contract.

6. We need to create a migrations file for this contract, so let's create a file inside of the `migrations` directory named: `2_setup_Foxcon2022.js` and add the following code:

```js
const Foxcon2022 = artifacts.require("Foxcon2022");

module.exports = function (deployer) {
  deployer.deploy(Foxcon2022);
};
```

7. Now we can run our Truffle Migrate command:

```bash
truffle migrate
```

And we will see some output in the terminal and if we look in our Ganache app, we will see two contracts:

![](./assets-readme/ganache-2.png)

## Import ERC-721 Open Zeppelin Contract

OpenZeppelin is a well-tested set of libraries written in Solidity that you can import to your smart contracts while code is potentially being generated, maintained and deployed by truffle.

We have used the OpenZeppelin ERC-721 Wizard to generate the following code:

```ts
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";

contract Foxcon2022 is ERC721, ERC721URIStorage {
    constructor() ERC721("Foxcon2022", "FXC22") {}

    function _baseURI() internal pure override returns (string memory) {
        return "https://ipfs.io/ipfs";
    }

    // The following functions are overrides required by Solidity.

    function _burn(uint256 tokenId) internal override(ERC721, ERC721URIStorage) {
        super._burn(tokenId);
    }

    function tokenURI(uint256 tokenId)
        public
        view
        override(ERC721, ERC721URIStorage)
        returns (string memory)
    {
        return super.tokenURI(tokenId);
    }
}
```

Let's compile what we have at this point:

```bash
truffle compile
```

Since we are importing a few OpenZeppelin files that in turn have their own dependencies, we will get much more than our one RPC contract `Foxcon2022.json`, built out into our `build/contracts` directory. As you can also see, these directories are ignored by git. 

![](./assets-readme/compile-oz-1.png)

As with anything that is generated by the compiler in our project, we don't really want this stuff pushed up to our GitHub repo.

We also see that OpenZeppelin has left us in a good place, everything is compiling just as it should, no warnings... Bet.

What we need to do next is to configure the details about out NFT tickets. We need to write the missing code that will give us individual NFT Tokens. Each ticket will be it's own token address. We will only create a select few, but our project could have many more if we wanted.

We want to set these tickets up so that when they are initially created, that we own them and can sell them.

## Creating Individual NFT Tokens

Let's replace the current `constructor()` with this new version of it, plus an extra solidity function to create eac of our NFT Tickets:

```ts
    constructor() ERC721("Foxcon2022", "FXC22") {
      // _private method
      // (to: who owns it?, tokenId: what token is owned?)
      _createTicket(msg.sender, 1, "");
      _createTicket(msg.sender, 2, "");
      _createTicket(msg.sender, 3, "");
      // ^ generates 3 token NFTs that we can sell as tickets
    }

    function _createTicket(address to, uint id, string memory url) private returns(bool) {
      _safeMint(to, id);
      return true;
    }
```

At this point we are going to delete our build folder and we want to migrate this contract and test it locally with Ganache & Truffle.

```bash
truffle migrate
```

If we check Ganache after the migration is done, we will see all of our contracts, they are not deployed, but they are there:

![](./assets-readme/migrate-oz-1.png)

As well, all of our build artifacts are back. We only deleted them to demonstrate that they get regenerated during compile, or migrations.

If we take the code inside of `Foxcon2022.sol` and paste it into the online Remix Solidity Editor and compile it, we could use the IDE's UI to play around with calling and accessing various functions that are provided to us through the OpenZeppelin inherited contracts. We could mint, setBalance and all sort's of cool things we can't easily do from our VS Code IDE without creating our own UI. Another interesting tool we could use is OneClickDapp, but we will get to more on those tools later.

## Setting up IPFS

We need a place to store our NFT images and accompanying metadata. For this we will use IPFS. WE don't want to use some unreliable storage, we want these assets to be accessible forever. We need an immutable storage facility that will hold our `json` metadata that points to our NFT Ticket image as well that stores information about our Ticket and we don't ever want it to change.

For this we will use IPFS.

Locally, we will install [IPFS Desktop](https://ipfs.io/#install), and go to the Files section in the app and drop in our `metadata-*.json` files from the `nft-ticket-data` directory.

![](./assets-readme/ipfs-1.png)

When we Control click on these json files inside of our IPFS app, we can get a CID address, here is one of mine: `QmZrZQ2ykEfKnZcoeaXGCiZ36eMKopCa7d9oUwX4Nw1z6P`.

Now if we tag that onto the end of an IPFS URL, we can view that file on the internet in our browser:

[ipfs.io/ipfs/QmZrZQ2ykEfKnZcoeaXGCiZ36eMKopCa7d9oUwX4Nw1z6P](https://ipfs.io/ipfs/QmZrZQ2ykEfKnZcoeaXGCiZ36eMKopCa7d9oUwX4Nw1z6P)

Now we cna use that address when generating our NFTs. As you might have guessed, these three CIDs are going to be pasted into the corresponding NFT TIckets:

```ts
    constructor() ERC721("Foxcon2022", "FXC22") {
      // _private method
      // (to: who owns it?, tokenId: what token is owned?)
      _createTicket(msg.sender, 1, "QmZrZQ2ykEfKnZcoeaXGCiZ36eMKopCa7d9oUwX4Nw1z6P");
      _createTicket(msg.sender, 2, "QmcX4jHMfXTc3UcEy7R721SmEdz2hGMte9dv4APv6GSKrF");
      _createTicket(msg.sender, 3, "Qmcywck6BmUNhHzn559XzjHWJBsUChKqyRP8XqBMHk9FTs");
      // ^ generates 3 token NFTs that we can sell as tickets
    }

    function _createTicket(address to, uint id, string memory url) private returns(bool) {
      _safeMint(to, id);
      _setTokenURI(id, url);
      return true;
    }
```

As well we have updated the `_createTicket()` method to assign both `id` and `url` when we create each NFT Ticket.
